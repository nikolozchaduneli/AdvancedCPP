PAGE 1 ------  

Sujet 2:
Une approche bibliothèque au JIT en C++ appliquée au traitement d’images :


Membres du groupe :

Youenn Loie
Maxime Brouillard
Nikoloz Chaduneli
William Te
Antoine Roubaud

PAGE 2 ------

Sommaire :


PAGE 3 ------

INTRODUCTION :

- Retranscription de l'algorithme de Van Herk en C++.

	L'algorithme de Van Herk consiste à dilater ou éroder une image. 

Les choix fait durant le projet :

- Par soucis de clareté / propreté, nous avons choisis de mettre nos fonctions dans le fichier dilate.hpp qui comporte les 3 versions demandées dans le sujet.

- Changement du flag dans CMakelist.txt std=c++20 en std=c++2a suggéré par le compilateur car celui que vous nous aviez donné ne marchais pas.

```
add_compile_options(-W -Wall -Werror -std=c++2a)
```

- Changement du prototype de fonction pour `dilate1d` en passant in et out par référence car, comme vous le faisiez, en copie, cela ne marche pas.

```
template<class T,class BinaryOperation>
void dilate1d(image2d<T> in, image2d<T> out, int k, BinaryOperation sup, T zero);
|
v
template<class T,class BinaryOperation>
void dilate1d(image2d<T> &in, image2d<T> &out, int k, BinaryOperation sup, T zero)
```

- Création d'un lambda fonction lors de l'appel à dilate pour remplacer std::min car cela ne marchais pas.

```
(SCREEN) dilate1d( (image2d<uint8_t>&)in, (image2d<uint8_t>&)out, std::min, UINT8_MAX);
|
v
dilate1d(in, in, 5, [](auto a, auto b) { return std::min(a, b); }, 0);
```

- Problème: Ne pas considérer la variable "zero" car nous ne comprenions pas comment s'en servir. 
	- Recherche: Suite à nos recherches, et au code dont nous pouvions nous inspirer. Nous ne comprenions pas quelles étaient les extensions et quel était le lien entre les extensions et le zéro dans la fonction. Nous hypothèses étaient qu'elles servaient à ne pas overflow de l'image pendant l'application de l'algorithme, et que le zéro servait à remplir les pixels d'extension avec une valeur donnée.
	- Solution: Nous n'avons pas utilisé la valeur zéro et avons appliqué l'algorithme sans utiliser la valeur zéro et en ne considérant pas les extensions.

- Un problème majeur que nous avons rencontré était la compréhension du sujet, en effet une explication de votre part aurait été appréciable.

- Problème: Erreur de compilation dans le switch de la fonction dilate1d
	- Recherche: Il y avait une erreur d'implémentation dans le switch que vous nous donniez pour la 2ème version, en effet, il manquais une variable à l'appel de la fonction dilate1d, (ainsi que le problème du std::min). De plus nous n'avons pas réussi à faire compiler le code lorque nous laissions ces typage aux appel de dilate1d (comme UINT8_MAX).
	( SCREEN ) 
	- Solution: nous les avons donc caster dans le type attendu par le compilateur pour pouvoir compiler le programme.
	( SCREEN )

```
case UINT8: dilate1d( (image2d<uint8_t>&)in, (image2d<uint8_t>&)out, k, [](auto a, auto b) { return std::min(a, b); }, (unsigned char)UINT8_MAX);
```

- Probleme: Nous avons eut beaucoup de mal à comprendre ASMJit.
	- Recherche: documentation à l'aide de plusieurs sites. [1] (METTRE UNE CATEGORIE DANS LA BIBLIO)
	- Solution: c'est pourquoi nous n'avons pu faire la partie 3.

Présentation des résultats :
- Résultats des benchmark :
	- 1 - Résultats de dilatation:
		
	- 2 - Résultats d'érosion:
	
	Conclusion:
 
Conclusion :
- Le sujet était compliqué et difficile à prendre en main sans explications, de plus les erreurs de typos dans le code que vous nous donniez nous ont ralentis. Le sujet était trop éloigné des notions vues en cours à notre goût. Il aurait fallut être un peu plus guidé ou avoir un sujet plus proche du cours.
